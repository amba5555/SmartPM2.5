# Implementation Checklist: Hyperlocal Air Quality Platform (Phase 1 MVP)

**Version:** 1.0  
**Date:** September 30, 2025  
**Based on PRD:** Hyperlocal Air Quality & Health Forecast Platform  
**Goal:** Build end-to-end data pipeline and dashboard for real-time AQI monitoring.  
**Timeline:** 4–6 weeks (10–15 hours/week).  
**Tools:** VS Code, GitHub, Supabase, Render, Vercel.

---

## Prerequisites
- [ ] ESP32 firmware deployed and publishing to HiveMQ (`smartpm25/sensor/data`).
- [ ] GitHub repository for source control.
- [ ] Accounts created: Supabase (free), Render (free), Vercel (free), HiveMQ Cloud (free).
- [ ] Basic knowledge: Python (backend), JavaScript (frontend), SQL (database).

---

## 1. Database Setup (Supabase)
**Goal:** Create secure, scalable storage for sensor data.  
**Estimated time:** 1–2 days.

- [ ] Create a new Supabase project.
- [ ] In the SQL editor, run the schema script below:

```sql
CREATE TABLE readings (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  device_id TEXT NOT NULL,
  pm1 INTEGER NOT NULL,
  pm25 INTEGER NOT NULL,
  pm10 INTEGER NOT NULL,
  aqi INTEGER NOT NULL,
  timestamp BIGINT NOT NULL,
  wifi_rssi INTEGER,
  ip_address TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
CREATE INDEX readings_device_id_idx ON readings(device_id);
CREATE INDEX readings_timestamp_idx ON readings(timestamp);
```

- [ ] Enable Row Level Security (RLS) and add policies for read access (or use Supabase Edge Functions for controlled access).
- [ ] Insert sample data to validate the schema.
- [ ] Record: Project URL, anon (public) key, and service role key (store securely).

**Success criteria:** Table exists and sample data is insertable/queryable.  
**Notes / Risks:** Monitor free-tier limits (storage, row inserts, bandwidth).

---

## 2. Backend Setup (Python + FastAPI on Render)
**Goal:** Subscribe to MQTT, validate/process incoming messages, store them in Supabase, and expose APIs for the frontend.  
**Estimated time:** 3–5 days.

- [ ] Create project skeleton:

```bash
mkdir backend && cd backend
python -m venv venv
source venv/bin/activate
```

- [ ] Install dependencies:

```bash
pip install fastapi uvicorn paho-mqtt supabase
```

- [ ] Implement `main.py`:
  - MQTT client subscribes to `smartpm25/sensor/data` (and optional status topics).
  - Parse and validate incoming JSON (schema, checksum if available).
  - Insert records into Supabase `readings` table.
  - Add REST endpoints:
    - `GET /api/readings/latest` → latest reading
    - `GET /api/readings/history?period=24h|7d|30d&device_id=...` → historical data

- [ ] Add configuration via environment variables (`SUPABASE_URL`, `SUPABASE_KEY`, `MQTT_BROKER`, `MQTT_USERNAME`, `MQTT_PASSWORD`).
- [ ] Add robust logging, error handling, and MQTT reconnect logic.
- [ ] Test locally with `uvicorn main:app --reload` and simulate MQTT messages (or use the device).
- [ ] Deploy to Render (connect to GitHub repo and set environment variables in Render dashboard).

**Success criteria:** Backend receives MQTT messages and writes to Supabase; APIs return expected JSON.  
**Notes / Risks:** Keep service role keys secure; monitor logs for connectivity issues.

---

## 3. Frontend Setup (Svelte + SvelteKit on Vercel)
**Goal:** Responsive dashboard showing live AQI, recent readings, and historical charts.  
**Estimated time:** 4–6 days.

- [ ] Scaffold SvelteKit app:

```bash
npm create svelte@latest frontend
cd frontend
npm install
```

- [ ] Add dependencies:

```bash
npm install @supabase/supabase-js chart.js
```

- [ ] Configure Supabase client in `src/lib/supabase.js` (use anon/public key for read-only frontend queries).
- [ ] Build main UI components:
  - AQI card / gauge (color-coded by AQI level).
  - Current readings (PM1, PM2.5, PM10, RSSI, IP).
  - Health recommendations component (based on AQI bands).
  - Historical chart component (24h, 7d, 30d) using Chart.js.

- [ ] Data flow:
  - Fetch latest reading on page load.
  - Poll backend every 10s (or use WebSocket / Server-Sent Events for push updates).
  - Allow selecting device_id to view different sensors (multi-sensor support).

- [ ] Test locally (`npm run dev`) and verify layout on desktop and mobile.
- [ ] Deploy to Vercel (connect GitHub repo, set env vars for production if needed).

**Success criteria:** Dashboard displays live data and historical charts, updates within 10s.  
**Notes / Risks:** If Svelte becomes a blocker, implement a minimal static page with plain JS and Chart.js and migrate later.

---

## 4. Integration & Testing
**Goal:** Validate end-to-end pipeline and user experience.  
**Estimated time:** 2–3 days.

- [ ] Point device(s) to HiveMQ and confirm messages appear in backend logs.
- [ ] Verify records appear in Supabase.
- [ ] Confirm frontend shows latest reading and history charts.
- [ ] Validate AQI calculations and health messages.
- [ ] Test multi-device flows and filters.
- [ ] Load test (basic): ensure latency < 10s and system handles expected message rate.
- [ ] Collect initial user feedback (students/staff) and note UX improvements.

**Success criteria:** Full pipeline validated; visible on staging/production URLs.

---

## 5. Documentation & Handover
**Goal:** Make the project reproducible and maintainable.  
**Estimated time:** 1–2 days.

- [ ] Add `docs/README.md` with quick-start steps for local dev, deploy, and DB setup.
- [ ] Add `.env.example` with variable names and descriptions.
- [ ] Document API endpoints and sample responses.
- [ ] Provide a troubleshooting section (common MQTT, network, and Supabase errors).

**Success criteria:** New team members can follow README to run the system locally.

---

## Phase 2 (Optional / Future)
- [ ] Research 24-hour AQI forecasting models (time series or simple ML).
- [ ] Prepare data pipeline for model training (export historical data from Supabase).
- [ ] Build alerting (email/SMS) for predicted high pollution events.

---

## Notes & References
- PRD: `docs/PRD.md`  
- Firmware: see `src/` (ESP32 code)  
- Keep secrets out of Git; use `include/MQTTConfig.example.h` for templates and add real files to `.gitignore`.

---

*Check items off as you complete them. If you want, I can create separate task issues on GitHub from this checklist.*